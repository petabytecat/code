<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Drop Time Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>Ball Drop Time vs. Distance</h1>
    <h3>Analyzing drop time with trendlines and error bars</h3>
    <canvas id="myChart" width="800" height="600"></canvas>
    <script>
        const ctx = document.getElementById('myChart').getContext('2d');

        const data = [
            {x: 0.05, y: 0.002, error: 0.0003},
            {x: 0.1, y: 0.0054, error: 0.0007},
            {x: 0.15, y: 0.01, error: 0.002},
            {x: 0.2, y: 0.015, error: 0.002},
            {x: 0.25, y: 0.021, error: 0.003},
            {x: 0.3, y: 0.032, error: 0.003},
            {x: 0.35, y: 0.036, error: 0.005},
            {x: 0.4, y: 0.046, error: 0.007}
        ];

        const calculateLeastSquares = (data) => {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            for (let i = 0; i < n; i++) {
                sumX += data[i].x;
                sumY += data[i].y;
                sumXY += data[i].x * data[i].y;
                sumXX += data[i].x * data[i].x;
            }
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            return { slope, intercept };
        };

        const { slope: normalSlope, intercept: normalIntercept } = calculateLeastSquares(data);

        const firstPoint = data[0];
        const lastPoint = data[data.length - 1];

        const maxSlope = (lastPoint.y + lastPoint.error - (firstPoint.y - firstPoint.error)) / (lastPoint.x);
        const minSlope = (lastPoint.y - lastPoint.error - (firstPoint.y + firstPoint.error)) / (lastPoint.x);

        const maxIntercept = (firstPoint.y - firstPoint.error) - maxSlope * (firstPoint.x);
        const minIntercept = (firstPoint.y + firstPoint.error) - minSlope * (firstPoint.x);

        const calculateRSquared = (data, slope, intercept) => {
            const yMean = data.reduce((sum, point) => sum + point.y, 0) / data.length;
            const ssTotal = data.reduce((sum, point) => sum + Math.pow(point.y - yMean, 2), 0);
            const ssResidual = data.reduce((sum, point) => sum + Math.pow(point.y - (slope * point.x + intercept), 2), 0);
            return 1 - (ssResidual / ssTotal);
        };

        const rSquared = calculateRSquared(data, normalSlope, normalIntercept);

        // Generate trendline data
        const trendlineData = (slope, intercept) => {
            return [{x: 0, y: intercept}, {x: 0.5, y: slope * 0.5 + intercept}];
        };

        new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Data Points',
                    data: data,
                    backgroundColor: 'rgba(0, 0, 255, 0.5)',
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    error: data.map(point => ({x: 0.0005, y: point.error}))
                }, {
                    label: `Normal Trendline (y = ${normalSlope.toFixed(4)}x + ${normalIntercept.toFixed(4)}, R² = ${rSquared.toFixed(4)})`,
                    data: trendlineData(normalSlope, normalIntercept),
                    type: 'line',
                    borderColor: 'rgba(0, 0, 0, 1)',
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0
                }, {
                    label: `Max Slope (y = ${maxSlope.toFixed(4)}x + ${maxIntercept.toFixed(4)})`,
                    data: trendlineData(maxSlope, maxIntercept),
                    type: 'line',
                    borderColor: 'rgba(139, 0, 0, 1)',
                    borderWidth: 1,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0
                }, {
                    label: `Min Slope (y = ${minSlope.toFixed(4)}x + ${minIntercept.toFixed(4)})`,
                    data: trendlineData(minSlope, minIntercept),
                    type: 'line',
                    borderColor: 'rgba(0, 100, 0, 1)',
                    borderWidth: 1,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: "Ball Drop Time Squared vs. Distance (with Uncertainty)",
                        font: {
                            size: 18,
                            weight: 'bold'
                        },
                        padding: {
                            top: 10,
                            bottom: 30
                        }
                    },
                    legend: {
                        display: true,
                        position: 'chartArea'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += `(${context.parsed.x.toFixed(3)}, ${context.parsed.y.toFixed(3)})`;
                                }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'Distance (D ± 0.001 m)'
                        },
                        min: 0,
                        max: 0.5
                    },
                    y: {
                        type: 'linear',
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Time Squared (s²)'
                        },
                        min: 0
                    }
                }
            },
            plugins: [{
                id: 'errorBars',
                afterDatasetsDraw(chart, args, options) {
                    const {ctx, data, chartArea: {top, bottom, left, right}, scales: {x, y}} = chart;

                    ctx.save();
                    data.datasets[0].data.forEach((dataPoint, index) => {
                        const xPos = x.getPixelForValue(dataPoint.x);
                        const yPos = y.getPixelForValue(dataPoint.y);
                        const yError = y.getPixelForValue(dataPoint.y + data.datasets[0].error[index].y) - yPos;
                        const xError = x.getPixelForValue(dataPoint.x + data.datasets[0].error[index].x) - xPos;

                        // Draw vertical error bar
                        ctx.beginPath();
                        ctx.moveTo(xPos, yPos - yError);
                        ctx.lineTo(xPos, yPos + yError);
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Draw horizontal error bar
                        ctx.beginPath();
                        ctx.moveTo(xPos - xError, yPos);
                        ctx.lineTo(xPos + xError, yPos);
                        ctx.stroke();

                        // Draw vertical error bar caps
                        ctx.beginPath();
                        ctx.moveTo(xPos - 3, yPos - yError);
                        ctx.lineTo(xPos + 3, yPos - yError);
                        ctx.moveTo(xPos - 3, yPos + yError);
                        ctx.lineTo(xPos + 3, yPos + yError);
                        ctx.stroke();

                        // Draw horizontal error bar caps
                        ctx.beginPath();
                        ctx.moveTo(xPos - xError, yPos - 3);
                        ctx.lineTo(xPos - xError, yPos + 3);
                        ctx.moveTo(xPos + xError, yPos - 3);
                        ctx.lineTo(xPos + xError, yPos + 3);
                        ctx.stroke();
                    });
                    ctx.restore();
                }
            }]
        });
    </script>
</body>
</html>
